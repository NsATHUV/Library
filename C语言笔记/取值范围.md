---
tags:
  - C语言/内容
aliases:
---
# 比特位

 -   CPU能读懂的最小单位——比特位，bit，b。
 -   内存机构的最小寻址单位——字节，Byte，B。
 -   1 Byte =8 bit
 -   一个字节最大可以表示的二进制数是`11111111`八个1，即为十进制的255 ，十六进制的`FF`。

## 引申概念——进制

 以下是一个表格，展示了二进制、十进制和十六进制之间的对应关系：

 | 二进制 (Binary) | 十进制 (Decimal) | 十六进制 (Hexadecimal) |
 | --------------- | ---------------- | ---------------------- |
 | 0000            | 0                | 0                      |
 | 0001            | 1                | 1                      |
 | 0010            | 2                | 2                      |
 | 0011            | 3                | 3                      |
 | 0100            | 4                | 4                      |
 | 0101            | 5                | 5                      |
 | 0110            | 6                | 6                      |
 | 0111            | 7                | 7                      |
 | 1000            | 8                | 8                      |
 | 1001            | 9                | 9                      |
 | 1010            | 10               | A                      |
 | 1011            | 11               | B                      |
 | 1100            | 12               | C                      |
 | 1101            | 13               | D                      |
 | 1110            | 14               | E                      |
 | 1111            | 15               | F                      |

 这个表格显示了二进制数值从 0 到 15 分别对应的十进制和十六进制表示。

### 讨论：int类型可存储的最大数值问题的讨论

 1.  在vs中使用[[库函数#sizeof()|sizeof()]]可以判断，int类型所占的字节为4字节，共8bit。

 2.  我们知道计算机存储的是二进制数，每个比特都只能是0或者1，那么int类型能存储的最大数理论上就是8个1（取决于编译系统，这里默认int类型占4个字节·Byte），根据二进制转换10进制公式：
     $$
     x^{1的位数}-1
     $$
     可知，`8bit`最大存储的数字理论上就是`(2^32)-1` ，最终结果是`4,294,967,295`。

 3.  但是我们通过下面的程序计算：

     ```c
     #include<stdio.h>
     #include<conio.h>
     #include<math.h>
     
     int main()
     {
     	int x;
     	x = pow(2, 32) - 1;
     	printf("x=%d", x);


     	_getch();
     	return 0;
     }
     ```
     
     最终结果为：`-2147483648`。和我们理论的数字相差甚远，并且还是负数。

 4.  这是因为INT是[[数据类型#signed 和 unsigned|signed]]类型数据，即为`带符号`的整数，所以实际上第1bit的位置存放的0和1的作用是标记数字的正负符号的，0代表正号，1代表负号。所以int能存储的最大值应为`(2^31)-1`。

 5.  此时我们将相关int的三种情况写为程序输出出来。
```c
#include<stdio.h>
#include<conio.h>
#include<math.h>

int main()
{
    //理论上的 int能存放的最大数：
    int x;
    x = pow(2, 32) - 1;
    printf("x=%d\n", x);
    //去掉符号后的真正的最大数：
    unsigned int ux;
    ux = pow(2, 32) - 1;
    printf("ux=%u\n", ux);
    //int本身能存放的最大数：
    x = pow(2, 31) - 1;
    printf("x=%u\n", x);

    _getch();
    return 0;
}
```
输出结果为
```c
x=-2147483648
ux=4294967295
x=2147483647
```
以上为对INT能存放的最大数的3种相关计算。